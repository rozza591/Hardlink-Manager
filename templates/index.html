<!DOCTYPE html>
<html>
<head>
    <title>Hardlink Manager</title>
    <link rel="icon" href="/static/logos/favicon.ico" type="image/x-icon">
     <style>
        /* --- Base and Layout Styles --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa; /* Light grey background */
            color: #212529; /* Dark text */
            transition: background-color 0.3s, color 0.3s; /* Smooth theme transitions */
        }
        .container {
            width: 90%;
            max-width: 800px; /* Limit maximum width for readability */
            margin: 20px auto; /* Center the container */
            background-color: #ffffff; /* White background for content */
            padding: 30px;
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Subtle shadow */
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .header-container {
            display: flex;
            align-items: center; /* Vertically align logo and title */
            justify-content: center; /* Center logo and title */
            margin-bottom: 25px;
            gap: 15px; /* Space between logo and title */
        }
        .logo { max-height: 45px; /* Limit logo height */ }
        h1 {
            margin: 0;
            font-size: 1.8em;
            color: #343a40; /* Slightly lighter dark for heading */
            text-align: center;
        }

        /* --- Form Styles --- */
        .form-group { margin-bottom: 20px; }
        label {
            display: block; /* Place label on its own line */
            margin-bottom: 8px;
            font-weight: 600; /* Bolder labels */
            color: #495057; /* Medium grey text */
        }
        input[type="text"] {
            width: 100%; /* Full width input */
            padding: 12px;
            border: 1px solid #ced4da; /* Light grey border */
            border-radius: 4px;
            box-sizing: border-box; /* Include padding and border in width */
            margin-top: 4px;
            transition: border-color 0.3s ease, background-color 0.3s, color 0.3s;
            background-color: #fff;
            color: #495057;
        }
        input[type="text"]:focus {
            border-color: #80bdff; /* Blue highlight on focus */
            outline: none; /* Remove default outline */
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); /* Subtle glow on focus */
        }
        small {
            font-size: 0.85em;
            color: #6c757d; /* Lighter grey for helper text */
            display: block;
            margin-top: 4px;
        }
        .checkbox-group label {
            display: inline-block; /* Keep checkboxes and labels on same line */
            margin-right: 15px;
            font-weight: normal; /* Normal weight for checkbox labels */
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle; /* Align checkbox with text */
        }
        .save-auto-group { /* Styling for the auto-save checkbox area */
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f0f0; /* Slightly different background */
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .save-auto-group label {
            display: inline-block;
            font-weight: normal;
            margin-left: 5px;
        }
        .save-auto-group small {
            font-size: 0.8em;
            color: #dc3545; /* Warning color (red) */
            margin-top: 5px;
        }

        /* --- Button Styles --- */
        .button-group { margin-top: 10px; } /* Group main action buttons */
        button {
            background-color: #007bff; /* Primary blue */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.3s ease;
            margin-top: 5px;
            margin-right: 8px;
            vertical-align: middle;
        }
        button:hover { background-color: #0056b3; /* Darker blue on hover */ }
        button:disabled {
            background-color: #6c757d; /* Grey when disabled */
            cursor: not-allowed;
            opacity: 0.7;
        }
        #clear-cache-btn { background-color: #6c757d; /* Grey for secondary action */ }
        #clear-cache-btn:hover { background-color: #5a6268; /* Darker grey on hover */ }
        .download-button { /* General style for download buttons */
            background-color: #17a2b8; /* Teal color */
            display: none; /* Hidden by default, shown via JS */
            margin-left: 5px; /* Space from previous button */
        }
        .download-button:hover { background-color: #138496; /* Darker teal on hover */ }

        /* --- Status & Progress Bar Styles --- */
        #status-message {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef; /* Light grey background */
            border: 1px solid #ced4da;
            border-radius: 5px;
            display: none; /* Hidden by default */
            flex-direction: column; /* Stack phase, details, progress bar vertically */
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
            text-align: center;
        }
        #status-phase { font-weight: bold; margin-bottom: 5px; }
        #status-details { font-size: 0.9em; color: #495057; margin-bottom: 8px; }
        .progress-bar-container {
            width: 80%; /* Make progress bar slightly narrower than status box */
            background-color: #d6d6d6; /* Grey background for the bar track */
            border-radius: 5px;
            height: 10px;
            overflow: hidden; /* Hide overflow for rounded corners */
            margin-top: 5px;
        }
        .progress-bar {
            width: 0%; /* Initial width */
            height: 100%;
            background-color: #007bff; /* Blue progress indicator */
            transition: width 0.3s ease-out; /* Smooth progress animation */
        }

        /* --- Results Area Styles --- */
        #results {
            margin-top: 30px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06); /* Lighter shadow for results */
            display: none; /* Hidden by default */
            transition: background-color 0.3s;
            border: 1px solid #e9ecef; /* Light border */
        }
        #results h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #343a40;
        }
        .results-button-bar { /* Container for download buttons */
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #dee2e6; /* Separator line */
        }
        #summary-stats { /* Box for summary statistics */
            border: 1px solid #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            background-color: #f8f9fa; /* Light background */
            transition: background-color 0.3s;
        }
        #summary-stats p { margin: 8px 0; font-size: 1.0em; }
        #summary-stats strong { /* Style for labels (e.g., "Initial Size:") */
            color: #343a40;
            min-width: 180px; /* Align values */
            display: inline-block;
            transition: color 0.3s;
        }
        #summary-stats hr { /* Dashed separator within summary */
            border: 0;
            border-top: 1px dashed #ccc;
            margin: 10px 0;
        }

        /* --- Link Actions (Dry Run Only) --- */
        #link-actions {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6; /* Separator line */
            text-align: center;
            display: none; /* Hidden by default */
            transition: border-color 0.3s;
        }
        #link-actions p { margin-bottom: 10px; }
        #link-actions button { /* Default style for hard link button */
            background-color: #28a745; /* Green */
            margin: 0 10px;
        }
        #link-actions button:hover { background-color: #218838; /* Darker green */ }
        #link-actions button.softlink { /* Specific style for soft link button */
            background-color: #ffc107; /* Yellow */
            color: #333; /* Dark text for yellow background */
        }
        #link-actions button.softlink:hover { background-color: #e0a800; /* Darker yellow */ }

        /* --- Error Message Style --- */
        #error-message {
            color: #dc3545; /* Red text */
            font-weight: bold;
            margin-bottom: 15px;
            background-color: #f8d7da; /* Light red background */
            border: 1px solid #f5c6cb; /* Red border */
            padding: 10px;
            border-radius: 4px;
            display: none; /* Hidden by default */
        }

        /* --- Duplicates List Styles --- */
        #duplicates h3 { /* Header for the duplicates list */
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            margin-bottom: 15px;
            color: #495057;
            transition: color 0.3s, border-color 0.3s;
        }
        #duplicates ul { padding-left: 0; list-style: none; /* Remove default list styling */ }
        .duplicate-set { /* Container for a single set of duplicates */
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #17a2b8; /* Teal accent border */
            border-radius: 4px;
            transition: background-color 0.3s, border-left-color 0.3s;
        }
        .duplicate-set.already-linked { /* Style modifier for already linked sets */
            border-left-color: #6c757d; /* Grey accent border */
            background-color: #e9ecef; /* Lighter grey background */
        }
        .duplicate-set.already-linked h4 { color: #495057; /* Grey heading */ }
        .duplicate-set h4 { /* Header for each duplicate set */
            margin-top: 0;
            margin-bottom: 10px;
            color: #343a40;
            font-size: 1.1em;
            transition: color 0.3s;
        }
        .duplicate-set li { /* Style for each file path entry */
            margin-bottom: 5px;
            color: #495057;
            word-break: break-all; /* Prevent long paths from overflowing */
            font-size: 0.95em;
            transition: color 0.3s;
        }
        /* --- MODIFICATION: Renamed class and adjusted styles --- */
        .hash-info { /* Style for the [Hash: ...] text */
            font-size: 0.8em;
            color: #6c757d; /* Keep color similar to inode */
            margin-left: 10px;
            transition: color 0.3s;
            font-family: monospace; /* Use monospace for hash */
        }
        .already-linked-tag { /* Style for the [Linked] tag */
            font-size: 0.8em;
            color: #28a745; /* Green */
            font-weight: bold;
            margin-left: 10px;
        }
        .size-info { /* Style for the size display */
            font-weight: bold;
            color: #6c757d;
            font-size: 0.9em;
            margin-bottom: 10px;
            transition: color 0.3s;
        }

        /* --- Dark Mode Toggle Button --- */
        .dark-toggle {
            position: fixed; /* Keep toggle in view */
            top: 15px;
            right: 15px;
            /* Default state (Light mode UI) */
            background-color: #eee;
            color: #333;
            border: 1px solid #ccc;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: background-color 0.3s, color 0.3s;
            z-index: 1000; /* Ensure it's above other elements */
        }
        .dark-toggle:hover { background-color: #ddd; /* Slightly darker on hover */ }
        .dark-toggle.active { /* Style when dark mode is ON */
            background-color: #333; /* Dark background */
            color: #fff;           /* Light text */
            border-color: #555;     /* Darker border */
        }
        .dark-toggle.active:hover { background-color: #555; /* Slightly lighter dark on hover */ }

        /* --- Dark Mode Theme Styles --- */
        body.dark-mode { background-color: #212529; color: #e9ecef; }
        body.dark-mode .container { background-color: #343a40; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); }
        body.dark-mode h1, body.dark-mode h2, body.dark-mode h3, body.dark-mode h4, body.dark-mode label, body.dark-mode strong, body.dark-mode small { color: #f8f9fa; }
        body.dark-mode input[type="text"] { background-color: #495057; border-color: #6c757d; color: #e9ecef; }
        body.dark-mode input[type="text"]:focus { border-color: #adb5bd; box-shadow: 0 0 0 0.2rem rgba(108, 117, 125, 0.5); }
        body.dark-mode .save-auto-group { background-color: #495057; border-color: #6c757d;}
        body.dark-mode .save-auto-group small { color: #ffc107; /* Lighter warning color */ }
        body.dark-mode button { background-color: #17a2b8; /* Teal buttons in dark mode */ }
        body.dark-mode button:hover { background-color: #138496; }
        body.dark-mode button:disabled { background-color: #495057; opacity: 0.7; }
        body.dark-mode #clear-cache-btn { background-color: #5a6268; }
        body.dark-mode #clear-cache-btn:hover { background-color: #495057; }
        body.dark-mode .download-button { background-color: #20c997; /* Brighter teal for download */ }
        body.dark-mode .download-button:hover { background-color: #1baa80; }
        body.dark-mode #status-message { background-color: #495057; border-color: #6c757d; color: #f8f9fa; }
        body.dark-mode #status-details { color: #ced4da;}
        body.dark-mode .progress-bar-container { background-color: #6c757d; }
        body.dark-mode .progress-bar { background-color: #17a2b8; /* Teal progress */ }
        body.dark-mode #results { background-color: #343a40; border-color: #495057; }
        body.dark-mode .results-button-bar { border-bottom-color: #495057; }
        body.dark-mode #summary-stats { background-color: #495057; border-color: #6c757d;}
        /* --- MODIFICATION: Dark mode style for hash --- */
        body.dark-mode .hash-info { color: #adb5bd; /* Lighter grey */ }
        body.dark-mode .already-linked-tag { color: #66bb6a; /* Lighter green */ }
        body.dark-mode .size-info { color: #adb5bd; }
        body.dark-mode #link-actions { border-top-color: #495057;}
        body.dark-mode #link-actions button { background-color: #4caf50; /* Slightly different green */ }
        body.dark-mode #link-actions button:hover { background-color: #45a049; }
        body.dark-mode #link-actions button.softlink { background-color: #ffeb3b; /* Brighter yellow */ color: #333;}
        body.dark-mode #link-actions button.softlink:hover { background-color: #fdd835;}
        body.dark-mode #error-message { background-color: #721c24; border-color: #f5c6cb; color: #f8d7da;} /* Darker red background */
        body.dark-mode #duplicates h3 { border-bottom-color: #495057; color: #ced4da;}
        body.dark-mode .duplicate-set { background-color: #495057; border-left-color: #20c997; /* Brighter teal accent */ }
        body.dark-mode .duplicate-set.already-linked { background-color: #5a6268; border-left-color: #adb5bd;}
        body.dark-mode .duplicate-set.already-linked h4 { color: #adb5bd;}
        body.dark-mode .duplicate-set li { color: #ced4da; /* Light grey list items */ }
    </style>
</head>
<body>
     <div class="dark-toggle" id="darkToggle">Dark Mode</div>

    <div class="container">
        <div class="header-container">
            <img src="/static/logos/hardlink-manager-logo-3.png" alt="Logo" class="logo">
            <h1>Hardlink Manager</h1>
        </div>

        <form id="scan-form">
            <div class="form-group">
                <label for="path1">Directory Path:</label>
                <input type="text" id="path1" name="path1" required placeholder="/data/media">
                <small>Enter the full path accessible by the server (e.g., `/data/movies` if mapped in Docker).</small>
            </div>

            <div class="form-group checkbox-group">
                 <label>Operation:</label><br>
                 <input type="checkbox" id="hardlink" name="hardlink" onclick="handleLinkTypeSelection(this)"> <label for="hardlink">Hard-Link Duplicates</label><br>
                 <input type="checkbox" id="softlink" name="softlink" onclick="handleLinkTypeSelection(this)"> <label for="softlink">Soft-Link Duplicates</label><br>
                 <input type="checkbox" id="dryrun" name="dryrun" checked onclick="handleDryRunSelection(this)"> <label for="dryrun">Dry Run (Report only)</label><br>
                 <small>Select ONE option. Dry Run recommended first.</small>
            </div>

            <div class="form-group save-auto-group">
                 <input type="checkbox" id="save-auto" name="save_auto"> <label for="save-auto">Save results automatically to input directory</label><br>
                 <small><strong>Warning:</strong> Ensure the server has write permission to the input directory. Saves JSON.</small>
            </div>

            <div class="button-group">
                <button type="submit" id="submit-btn">Start Scan</button>
                <button type="button" id="clear-cache-btn">Clear Results</button>
            </div>
        </form>

        <div id="status-message">
            <div id="status-phase">Initializing...</div>
            <div id="status-details">Please wait.</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar-inner"></div>
            </div>
        </div>

        <div id="error-message"></div>

        <div id="results">
            <h2>Scan Results</h2>
            <div class="results-button-bar">
                <button type="button" id="download-json-btn" class="download-button">Download JSON</button>
            </div>
            <div id="summary-stats">
                <p><strong>Overall Status:</strong> <span id="result-action">N/A</span></p>
                 <hr>
                <p><strong>Initial Size:</strong> <span id="result-before-size">N/A</span></p>
                <p><strong>Final Size (Theoretical):</strong> <span id="result-after-size">N/A</span></p>
                <p><strong>Space Saved:</strong> <span id="result-savings">N/A</span></p>
                <p><strong>Duration:</strong> <span id="result-duration">N/A</span></p>
            </div>
            <div id="link-actions">
                 <p>Perform linking based on this dry run?</p>
                 <button id="perform-hardlink-btn" data-link-type="hard">Perform Hard Link</button>
                 <button id="perform-softlink-btn" data-link-type="soft" class="softlink">Perform Soft Link</button>
             </div>
             <div id="duplicates">
                </div>
        </div>
    </div>

    <script>
        // --- Get References to UI Elements ---
        const form = document.getElementById("scan-form");
        const pathInput = document.getElementById("path1");
        const hardlinkCheckbox = document.getElementById("hardlink");
        const softlinkCheckbox = document.getElementById("softlink");
        const dryrunCheckbox = document.getElementById("dryrun");
        const saveAutoCheckbox = document.getElementById("save-auto");
        const submitButton = document.getElementById("submit-btn");
        const statusMessage = document.getElementById("status-message");
        const statusPhase = document.getElementById("status-phase");
        const statusDetails = document.getElementById("status-details");
        const progressBar = document.getElementById("progress-bar-inner");
        const resultsDiv = document.getElementById("results");
        const errorMessageDiv = document.getElementById("error-message");
        const duplicatesDiv = document.getElementById("duplicates");
        const clearCacheBtn = document.getElementById("clear-cache-btn");
        const darkToggle = document.getElementById('darkToggle');
        const resultAction = document.getElementById("result-action");
        const resultBeforeSize = document.getElementById("result-before-size");
        const resultAfterSize = document.getElementById("result-after-size");
        const resultSavings = document.getElementById("result-savings");
        const resultDuration = document.getElementById("result-duration");
        const linkActionsDiv = document.getElementById("link-actions");
        const hardlinkBtn = document.getElementById("perform-hardlink-btn");
        const softlinkBtn = document.getElementById("perform-softlink-btn");
        const downloadJsonBtn = document.getElementById("download-json-btn");

        // --- State Variables ---
        let currentScanId = null;
        let currentLinkOpId = null;
        let scanPollInterval = null;
        let linkPollInterval = null;
        let lastCompletedScanId = null;

        // --- Event Listeners ---
        submitButton.addEventListener("click", (e) => {
            e.preventDefault();
            if (!pathInput.value.trim()) { showError("Please enter a directory path."); pathInput.focus(); return; }
            if (!hardlinkCheckbox.checked && !softlinkCheckbox.checked && !dryrunCheckbox.checked) { showError("Please select an operation (Hardlink, Softlink, or Dry Run)."); return; }
            startScan();
        });
        clearCacheBtn.addEventListener("click", clearResults);
        darkToggle.addEventListener('click', () => toggleDarkMode(true));
        hardlinkBtn.addEventListener("click", () => performLink('hard'));
        softlinkBtn.addEventListener("click", () => performLink('soft'));
        downloadJsonBtn.addEventListener("click", downloadJson);

        // --- Initialization ---
        if (localStorage.getItem('darkMode') === 'enabled') {
             document.body.classList.add('dark-mode');
             toggleDarkMode(false);
        } else {
            darkToggle.textContent = 'Dark Mode';
            darkToggle.classList.remove('active');
        }

        // --- Checkbox Logic ---
        function handleLinkTypeSelection(checkbox) {
            if (checkbox.checked) {
                dryrunCheckbox.checked = false;
                if (checkbox.id === 'hardlink') softlinkCheckbox.checked = false;
                else if (checkbox.id === 'softlink') hardlinkCheckbox.checked = false;
            }
        }
        function handleDryRunSelection(checkbox) {
            if (checkbox.checked) {
                hardlinkCheckbox.checked = false;
                softlinkCheckbox.checked = false;
            }
        }

        // --- Core Application Functions ---
        function startScan() {
            lastCompletedScanId = null;
            downloadJsonBtn.style.display = 'none';
            resetStatusUI("Starting scan...");
            resultsDiv.style.display = "none";
            linkActionsDiv.style.display = "none";
            errorMessageDiv.style.display = "none";
            duplicatesDiv.innerHTML = "";
            clearResultStats();
            if (scanPollInterval) clearInterval(scanPollInterval);
            if (linkPollInterval) clearInterval(linkPollInterval);
            const formData = new FormData(form);
            submitButton.disabled = true; submitButton.textContent = 'Scanning...';
            pathInput.disabled = true;
            hardlinkCheckbox.disabled = true; softlinkCheckbox.disabled = true;
            dryrunCheckbox.disabled = true; saveAutoCheckbox.disabled = true;
            clearCacheBtn.disabled = true;

            fetch("/run_scan", { method: "POST", body: formData })
            .then(handleFetchResponse)
            .then(data => {
                if (data.status === "scan process started" && data.scan_id) {
                    currentScanId = data.scan_id;
                    updateStatusUI("Scan Queued", "Waiting...", 0);
                    pollForProgress(currentScanId, pollScanProgress);
                } else {
                    throw new Error("Unexpected response starting scan: " + (data.error || JSON.stringify(data)));
                }
            }).catch(error => {
                handleFetchError(error, "Scan Start");
                resetStatusUI("Scan failed to start.", true);
                resetScanFormState();
            });
        }

        function resetScanFormState() {
            submitButton.textContent = 'Start Scan'; submitButton.disabled = false;
            pathInput.disabled = false;
            hardlinkCheckbox.disabled = false; softlinkCheckbox.disabled = false;
            dryrunCheckbox.disabled = false; saveAutoCheckbox.disabled = false;
            clearCacheBtn.disabled = false;
            currentScanId = null;
            if (scanPollInterval) { clearInterval(scanPollInterval); scanPollInterval = null; }
        }

        function performLink(linkType) {
            if (!lastCompletedScanId) { showError("Cannot perform link: No completed dry run scan ID available."); return; }
            if (!confirm(`Confirm ${linkType} linking based on the last dry run (ID: ${lastCompletedScanId})? This modifies files.`)) return;
            hardlinkBtn.disabled = true; softlinkBtn.disabled = true;
            linkActionsDiv.style.display = "none";
            resetStatusUI(`Starting ${linkType} linking...`);
            const formData = new FormData(); formData.append('link_type', linkType);

             fetch(`/perform_link/${lastCompletedScanId}`, { method: "POST", body: formData })
            .then(handleFetchResponse)
            .then(data => {
                 if (data.status === "linking process started" && data.link_op_id) {
                      currentLinkOpId = data.link_op_id;
                      updateStatusUI("Linking Initialized", "Waiting...", 0);
                      pollForProgress(currentLinkOpId, pollLinkProgress);
                 } else { throw new Error("Unexpected response starting linking: "+ (data.error || JSON.stringify(data))); }
            }).catch(error => { handleFetchError(error, `Start ${linkType} Link`); resetStatusUI(`Failed to start ${linkType} linking.`, true); });
        }

        // --- Polling Functions ---
        function pollForProgress(id, pollFunction, intervalMs = 1500) {
            if (id === currentScanId && scanPollInterval) clearInterval(scanPollInterval);
            if (id === currentLinkOpId && linkPollInterval) clearInterval(linkPollInterval);
            const interval = setInterval(() => {
                if ((pollFunction === pollScanProgress && id !== currentScanId) || (pollFunction === pollLinkProgress && id !== currentLinkOpId)) { console.log(`Polling stopped for ${id}.`); clearInterval(interval); return; }
                pollFunction(id, interval);
            }, intervalMs);
            if (pollFunction === pollScanProgress) scanPollInterval = interval;
            if (pollFunction === pollLinkProgress) linkPollInterval = interval;
        }
        function pollScanProgress(scanId, interval) {
            fetch(`/get_progress/${scanId}`).then(handleFetchResponse).then(data => {
                 if (data.status === "done" || data.status === "error") { clearInterval(interval); scanPollInterval = null; updateStatusUI(data.phase || (data.status === "done" ? "Scan Complete" : "Scan Error"), data.status, 100); fetchResults(scanId); resetScanFormState(); }
                 else if (data.status === "unknown") { clearInterval(interval); scanPollInterval = null; showError("Scan ID lost."); resetStatusUI("Scan lost.", true); resetScanFormState(); }
                 else { updateStatusUI(data.phase || "Processing", data.status || "Working...", data.percentage || 0); }
            }).catch(error => { clearInterval(interval); scanPollInterval = null; handleFetchError(error, "Scan Poll"); resetStatusUI("Polling error.", true); resetScanFormState(); });
        }
        function pollLinkProgress(linkOpId, interval) {
            fetch(`/get_link_progress/${linkOpId}`).then(handleFetchResponse).then(data => {
                 if (data.status === "done" || data.status === "error") { clearInterval(interval); linkPollInterval = null; updateStatusUI(data.phase || (data.status === "done" ? "Linking Complete" : "Linking Error"), "Fetching final results...", 100); fetchLinkResults(linkOpId); }
                 else if (data.status === "unknown") { clearInterval(interval); linkPollInterval = null; showError("Link operation ID lost."); resetStatusUI("Linking operation lost.", true); }
                 else { updateStatusUI(data.phase || "Linking", data.status || "Working...", data.percentage || 0); }
            }).catch(error => { clearInterval(interval); linkPollInterval = null; handleFetchError(error, "Link Poll"); resetStatusUI("Link polling error.", true); });
         }

        // --- Result Fetching ---
         function fetchResults(scanId) {
             updateStatusUI("Fetching Scan Results", "Please wait...", 100);
             fetch(`/get_results/${scanId}`).then(handleFetchResponse).then(data => {
                 statusMessage.style.display = "none"; resultsDiv.style.display = "block";
                 errorMessageDiv.style.display = "none"; if (data.error) { showError(data.error); }
                 displayScanResults(data, scanId);
             }).catch(error => { handleFetchError(error, "Fetch Scan Results"); resetStatusUI("Failed to get scan results.", true); });
         }
         function fetchLinkResults(linkOpId) {
             updateStatusUI("Fetching Link Results", "Please wait...", 100);
             fetch(`/get_link_result/${linkOpId}`).then(handleFetchResponse).then(data => {
                 statusMessage.style.display = "none"; resultsDiv.style.display = "block";
                 errorMessageDiv.style.display = "none"; if (data.error) { showError(data.error); }
                 displayLinkResults(data);
             }).catch(error => { handleFetchError(error, "Fetch Link Results"); resetStatusUI("Failed to get link results.", true); });
         }

        // --- Display Functions ---
        /**
         * Renders the scan results data into the HTML elements.
         * Populates summary stats, shows link buttons (if dry run), and lists duplicates.
         * MODIFIED to show hash instead of inode.
         * @param {object} data - The results object received from the backend.
         * @param {string} scanId - The ID of the scan these results belong to.
         */
        function displayScanResults(data, scanId) {
             linkActionsDiv.style.display = "none"; hardlinkBtn.disabled = false; softlinkBtn.disabled = false;
             downloadJsonBtn.style.display = 'none';
             lastCompletedScanId = null;
             clearResultStats();

             if (!data || !data.summary) { showError("Incomplete scan results received."); return; }
             const summary = data.summary; const isDryRun = summary.is_dry_run;
             const hasAnyDuplicates = Array.isArray(data.duplicates) && data.duplicates.length > 0;
             const hasUnlinkedDuplicates = hasAnyDuplicates && summary.potential_savings > 0;

             resultAction.textContent = summary.action_taken || 'N/A';
             resultBeforeSize.textContent = formatBytes(summary.before_size);
             resultSavings.textContent = formatBytes(summary.potential_savings) + (hasUnlinkedDuplicates && isDryRun ? ' (Potential)' : (hasUnlinkedDuplicates ? ' (Actual)' : ' (None)'));
             resultAfterSize.textContent = formatBytes(summary.after_size) + (isDryRun ? " (Theoretical)" : "");
             resultDuration.textContent = summary.duration ? `${summary.duration.toFixed(2)} s` : 'N/A';

             if (isDryRun && hasUnlinkedDuplicates) { linkActionsDiv.style.display = "block"; }

            if (data.download_json_available && scanId) {
                downloadJsonBtn.style.display = 'inline-block';
                lastCompletedScanId = scanId;
            }
            // PDF Button check removed

            if(lastCompletedScanId) console.log("Download buttons updated for scan:", lastCompletedScanId);

            // --- Display Duplicate Sets List (Modified for Hash) ---
            if (Array.isArray(data.duplicates) && data.duplicates.length > 0) {
                let html = "<h3>Duplicate File Sets Found:</h3>";
                data.duplicates.forEach((set_with_size, index) => {
                     if (!Array.isArray(set_with_size) || set_with_size.length < 2) return;
                     const sizeInfo = set_with_size[0];
                     const fileInfos = set_with_size.slice(1);
                     const isSetAlreadyLinked = fileInfos[0]?.already_linked === true;
                     html += `<div class="duplicate-set ${isSetAlreadyLinked ? 'already-linked' : ''}">`;
                     html += `<h4>Set #${index + 1} (${fileInfos.length} files)${isSetAlreadyLinked ? ' - Already Linked' : ''}</h4>`;
                     if(sizeInfo) { html += `<p class="size-info">${escapeHtml(sizeInfo)}</p>`; }
                     html += "<ul>";
                     fileInfos.forEach((fileInfo, fileIndex) => {
                         const isOriginal = fileIndex === 0;
                         const filePath = escapeHtml(fileInfo.path);
                         // --- MODIFICATION START ---
                         // Get the hash (provide default if missing) and shorten it for display
                         const fullHash = fileInfo.hash || 'N/A';
                         const shortHash = fullHash.length > 8 ? fullHash.substring(0, 8) + '...' : fullHash;
                         const hashDisplay = escapeHtml(shortHash);
                         // --- MODIFICATION END ---
                         const linkedTag = fileInfo.already_linked ? '<span class="already-linked-tag">[Linked]</span>' : '';
                         const originalTag = isOriginal ? ' <strong style="font-size: 0.85em;">(Keep This)</strong>' : '';
                         // --- MODIFICATION: Use hash-info class and display hash ---
                         html += `<li ${isOriginal?'style="font-weight:bold;"':''}>${filePath}<span class="hash-info" title="${escapeHtml(fullHash)}">[Hash: ${hashDisplay}]</span>${linkedTag}${originalTag}</li>`;
                     });
                     html += "</ul></div>";
                });
                duplicatesDiv.innerHTML = html;
            } else if (summary.no_duplicates) { duplicatesDiv.innerHTML = "<p>No duplicate files found.</p>"; }
            else { duplicatesDiv.innerHTML = "<p>No duplicate sets to display.</p>"; }
        }

        /**
         * Updates the results display (primarily the summary section) after a
         * linking operation completes.
         * @param {object} data - The results object received from the backend link result endpoint.
         */
        function displayLinkResults(data) {
            if (!data || !data.summary) { showError("Incomplete link results received."); return; }
            resultAction.textContent = data.summary || 'Linking finished.';
             if (data.space_saved !== undefined && data.space_saved !== "Verification failed, savings uncertain") { resultSavings.textContent = formatBytes(data.space_saved) + ' (Actual)'; }
             else if (data.space_saved === "Verification failed, savings uncertain") { resultSavings.textContent = 'Verification failed, savings uncertain'; }
             linkActionsDiv.style.display = "none";

            // --- Update Download Buttons State (based on original scan) ---
            if (data.download_json_available && lastCompletedScanId) { downloadJsonBtn.style.display = 'inline-block'; }
            else { downloadJsonBtn.style.display = 'none'; }
            // PDF Button check removed

            if(lastCompletedScanId) console.log("Download buttons updated after linking, for original scan:", lastCompletedScanId);
         }

        // --- Download Functions ---
        function downloadJson() {
            if (!lastCompletedScanId) { showError("Cannot download JSON: No completed scan ID available."); return; }
            console.log(`Triggering JSON download for scan ID: ${lastCompletedScanId}`);
            window.location.href = `/download_results/${lastCompletedScanId}/json`;
        }

        // --- UI & Utility Functions ---
        function resetStatusUI(message="", isError=false) { statusPhase.textContent=message; statusDetails.textContent=""; progressBar.style.width=isError?"100%":"0%"; progressBar.style.backgroundColor=isError?"#dc3545":"#007bff"; statusMessage.style.display=message?"flex":"none"; }
        function updateStatusUI(phase, details, percentage) { statusPhase.textContent=phase||"Processing"; statusDetails.textContent=details||"..."; const clampedPercentage = Math.max(0, Math.min(100, percentage || 0)); progressBar.style.width=`${clampedPercentage}%`; progressBar.style.backgroundColor="#007bff"; statusMessage.style.display="flex"; }
        function clearResultStats() { resultAction.textContent='N/A'; resultBeforeSize.textContent='N/A'; resultAfterSize.textContent='N/A'; resultSavings.textContent='N/A'; resultDuration.textContent='N/A'; }
        function showError(message) { console.error("UI Error:", message); errorMessageDiv.textContent = message; errorMessageDiv.style.display = "block"; }
        function clearResults() {
            if (currentScanId || currentLinkOpId) { alert("Cannot clear results while an operation is in progress."); return; }
            resultsDiv.style.display="none"; errorMessageDiv.style.display="none"; duplicatesDiv.innerHTML="";
            clearResultStats(); resetStatusUI(); linkActionsDiv.style.display="none";
            downloadJsonBtn.style.display = 'none';
            lastCompletedScanId=null;
            fetch("/clear_cache",{method:"POST"}).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`)).then(d => console.log("Clear Cache:", d.message)).catch(e => console.error("Clear cache failed:", e));
        }
        function toggleDarkMode(doToggleAndSave) {
            const body = document.body;
            if (doToggleAndSave) { body.classList.toggle('dark-mode'); }
            const isActive = body.classList.contains('dark-mode');
            if (isActive) { darkToggle.textContent = 'Light Mode'; darkToggle.classList.add('active'); }
            else { darkToggle.textContent = 'Dark Mode'; darkToggle.classList.remove('active'); }
            if (doToggleAndSave) {
                if (isActive) { localStorage.setItem('darkMode','enabled'); }
                else { localStorage.removeItem('darkMode'); }
            }
        }
        function escapeHtml(unsafe) { if(typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;"); }
        function formatBytes(bytes, d=2) { if(bytes===undefined||bytes===null||isNaN(bytes)||bytes<0) return '0 Bytes'; if (bytes < 1) return '0 Bytes'; const k=1024; const dm=d<0?0:d; const sizes=['Bytes','KB','MB','GB','TB','PB','EB','ZB','YB']; const i=Math.floor(Math.log(bytes)/Math.log(k)); const validIndex = Math.min(i, sizes.length - 1); return `${parseFloat((bytes/Math.pow(k,validIndex)).toFixed(dm))} ${sizes[validIndex]}`; }
        async function handleFetchResponse(response) { if (!response.ok) { let errorDetail = `HTTP ${response.status}`; try { const errorData = await response.json(); errorDetail = errorData.error || JSON.stringify(errorData); } catch (e) {} throw new Error(errorDetail); } return response.json(); }
        function handleFetchError(error, context="Fetch") { console.error(`Error during ${context}:`, error); showError(`Operation failed (${context}): ${error.message}`); }

    </script>
</body>
</html>